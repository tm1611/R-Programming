---
title: "4. Writing Functions in R"
author: "Timo Meiendresch"
knit: (function(input_file, encoding) {
  out_dir <- 'html_files';
  rmarkdown::render(input_file,
  encoding=encoding,
  output_file=file.path(dirname(input_file), out_dir, 'Intermediate_R.html'))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=F}
library(purrr)
```

# Functions in R
Recall the elements of a function in R: 

- formals
- body
- environment



```{r}
# typical function definition
add <- function(x, y=1){
  x+y
}

# 
args(add)
formals(add)
body(add)
environment(add)
```

- Last expression evaluated in a function is the return value
- `return(value)` forces the function to stop execution and return value 
- anonymous functions: functions without a name

```{r}
# anonymous function
(function(x){x+1})(2)
```

Three parts of a function:

- arguments
- body
- environment 

### Environments
Scoping describes how R looks up values by name. If a name isn't defined inside a function, R will look one level up.

```{r}
x <- 2
g <- function(){
  y <- 1
  c(x,y)
}

g()

# 


```

Scoping describes where, not when, to look for a value

```{r}
# depends on environment 
f <- function() x
x <- 15
f()

# x in env is change
x <- 20
f()
```

- When you call a function, a new environment is made for the function to do its work.
- New env is populated with the argument values
- Objects are looked for first in this environment

### Data Structures
```{r}
typeof(letters)
typeof(1:10)
typeof(NULL)
length(NULL)
typeof(NA)
length(NA)
```

- Missing values are contagious!

Lists:

- Useful because they can contain heterogeneous objects
- complicated return objects are lists, ie from lm()

### for loops
Parts of a for loop

- sequence
- body
- 

```{r}
# looping over cols in a df
df <- data.frame(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

for (i in 1:ncol(df)) {
  print(median(df[[i]]))
}

```

Moving forward, we'll see a safer way to generate the sequence using `seq_along()` and saving the output instead of printing it. 

```{r}
# Replace the 1:ncol(df) sequence
for (i in seq_along(df)) {
  print(median(df[[i]]))
}

# Create an empty data frame
empty_df <- data.frame()

# Repeat for loop to verify there is no error
for (i in seq_along(empty_df)) {
  print(median(empty_df[[i]]))
}

# Create new double vector: output
output <- vector(mode = "double", ncol(df))

# Alter the loop
for (i in seq_along(df)) {
  # Change code to store result in output
  output[[i]] <- median(df[[i]])
}

# Print output
print(output)
```

# When and how you should write a function

### When?

- Copy-paste rule of thumb: Whenever you have copied-and-pasted twice, it's time to write a function

```{r}
# Define example vector x
x <- c(1:10, NA)

# Define rng
rng <- range(x, na.rm=TRUE)

# Rewrite this snippet to refer to the elements of rng
(x - min(x, na.rm = TRUE)) /
  (rng[2] - rng[1])

# Use this in function
rescale01 <- function(x) {
  rng <- range(x, na.rm=TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

# Test your function, call rescale01 using the vector x as the argument
rescale01(x)
```

### How?

1. Start with a simple problem. It is helpful if you know the answer.
2. Get a working snipped of code.
3. Rewrite to use temporary variables. Rewrite for clarity. Snippet is the body of the function. Temporary arguments are then the inputs
4. Turn into a function

```{r}
# Define example vectors x and y
x <- c( 1, 2, NA, 3, NA)
y <- c(NA, 3, NA, 3,  4)

# Count how many elements are missing in both x and y
sum(is.na(x) & is.na(y))

# Turn this snippet into a function: both_na()
both_na <- function(x,y){
  sum(is.na(x) & is.na(y))
}
```

Note that this function only works in cases where x and y have the same length. 

### How to write a good function?
Function is

- correct
- understandable
- readable for humans and computers
- correct + understandable = obviously correct

Naming the function as a verb which describes what it does is a good start. In addition, we should not use function names that are already taken nor use variables which have already a meaning (e.g. `T` or `c`).

```{r}
# Altered mean_ci function
mean_ci <- function(x, level = 0.95) {
  if (length(x) == 0) {
    warning("`x` was empty", 
    interval <- c(-Inf, Inf))
    return(interval)
  } else {
    se <- sd(x) / sqrt(length(x))
    alpha <- 1 - level
    mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
  }
}

mean_ci(numeric(0))
mean_ci(x)

# replace_missings function
replace_missings <- function(x, replacement) {
  x[is.na(x)] <- replacement
  cat(sum(is.na(x)), replacement, "\n")
  x
}

replace_missings(x, 0)

# A few more tweaks...
replace_missings <- function(x, replacement) {
  is_miss <- is.na(x)
  x[is_miss] <- replacement
  
  # Rewrite to use message()
  message(sum(is_miss), " missings replaced by the value ", replacement)
  x
}

replace_missings(x, replacement=10)

```

# Functional Programming

- Alternatives to the for-loop.

1. Rely on domain knowledge
2. Use variables
3. Extract out common code

```{r}
# Initialize output vector
output <- numeric(ncol(df))

for (i in seq_along(df)){
  output[i] <- median(df[[i]])
}

# turn this code into col_median()
col_median <- function(df){
  output <- numeric(ncol(df))
  for (i in seq_along(df)){
    output[[i]] <- median(df[[i]])
  }
  output
}

col_median(df)

# change to col_mean()
col_mean <- function(df) {
  output <- numeric(ncol(df))
  for (i in seq_along(df)) {
    output[[i]] <- mean(df[[i]])
  }
  output
}

# Define col_sd() function
col_sd <- function(df) {
  output <- numeric(length(df))
  for (i in seq_along(df)) {
    output[[i]] <- sd(df[[i]])
  }
  output
}

```

We just copied and paste the function `col_median` two times! This is a sign that we need to write a function! We start with a simple example first...

```{r}
# Add a second argument called power
f <- function(x, power) {
    # Edit the body to return absolute deviations raised to power
    (abs(x - mean(x)))^power
}
```

Note that functions can be arguments too!

```{r}
# col_sumamry function
col_summary <- function(df, fun){
  output <- numeric(length(df))
  for (i in seq_along(df)){
    output[i] <- fun(df[[i]])
  }
  output
}

col_summary(df, fun = median)
col_summary(df, fun = mean)
col_summary(df, fun = sd)

# Find the column IQRs using col_summary()
col_summary(df, fun = IQR)

```

### Introducing purrr
Passing functions as arguments is a principle that we've already seen with the apply family functions. Now, we want to introduce into a whole family of functions with similar workings. The `map()` functions in the `purrr` package.

Every map functions works the same way:
```r
map_dbl(.x, .f, ...)
```

1. Loop over a vector .x
2. Do something to each element .f
3. Return the results

There is one function for each type of vector:

- `map()` returns a list
- `map_dbl()` returns a double vector
- `map_lgl()` returns a logical vector
- `map_int()` returns a integer vector
- `map_chr()` returns a character vector

Now, let's use `map_dbl()` like we have used our summary function before:

```{r}
# Use map_dbl() to find column means
map_dbl(df, mean)

# Use map_dbl() to column medians
map_dbl(df, median)

# Use map_dbl() to find column standard deviations
map_dbl(df, sd)
```

Check the type of an individual output (e.g. of a dataframe) to determine which `map_` funciton is appropriate. 

### Shortcuts for specifying .f

- Using `~`to define an anonymous function on the fly

Data that will be used are a subset of the `mtcars` data.

```{r}
cyl <- split(mtcars, mtcars$cyl)
str(cyl)
head(cyl[[1]])
```

The objective is to fit a regression to each of the data frames in cyl and quantify the relationshiop between mpg and wt. Focus on slopes

```{r}
# structure of cyl
str(cyl)

# first element into four_cyls
four_cyls <- cyl[[1]]

# linear regression of mpg on wt using four_cyls
lm(mpg ~ wt, data=four_cyls)

# Rewrite to call an anonymous function
map(cyl, function(df) lm(mpg ~ wt, df))

# Rewrite to use the formula shortcut instead
map(cyl, ~lm(mpg ~ wt, data = .))

# Save the result from the previous exercise to the variable models
models <- map(cyl, ~ lm(mpg ~ wt, data = .))

# Use map and coef to get the coefficients for each model: coefs
coefs <- map(models, coef)

# Use string shortcut to extract the wt coefficient 
map(coefs, "wt")

# pull out the second element
map_dbl(coefs, 2)

```
Using the pipe operator:

```{r}
# Define models 
models <- mtcars %>% 
  split(mtcars$cyl) %>%
  map(~ lm(mpg ~ wt, data = .))

# Rewrite to be a single command using pipes 
summaries <- models %>%
  map(summary) %>%
  map_dbl("r.squared")
```

# Advanced inputs and outputs








