---
title: "4. Writing Functions in R"
author: "Timo Meiendresch"
knit: (function(input_file, encoding) {
  out_dir <- 'html_files';
  rmarkdown::render(input_file,
  encoding=encoding,
  output_file=file.path(dirname(input_file), out_dir, 'Intermediate_R.html'))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Functions in R
Recall the elements of a function in R: 

- formals
- body
- environment

```{r}
# typical function definition
add <- function(x, y=1){
  x+y
}

# 
args(add)
formals(add)
body(add)
environment(add)
```

- Last expression evaluated in a function is the return value
- `return(value)` forces the function to stop execution and return value 
- anonymous functions: functions without a name

```{r}
# anonymous function
(function(x){x+1})(2)
```

Three parts of a function:

- arguments
- body
- environment 

### Environments
Scoping describes how R looks up values by name. If a name isn't defined inside a function, R will look one level up.

```{r}
x <- 2
g <- function(){
  y <- 1
  c(x,y)
}

g()

# 


```

Scoping describes where, not when, to look for a value

```{r}
# depends on environment 
f <- function() x
x <- 15
f()

# x in env is change
x <- 20
f()
```

- When you call a function, a new environment is made for the function to do its work.
- New env is populated with the argument values
- Objects are looked for first in this environment

### Data Structures
```{r}
typeof(letters)
typeof(1:10)
typeof(NULL)
length(NULL)
typeof(NA)
length(NA)
```

- Missing values are contagious!

Lists:

- Useful because they can contain heterogeneous objects
- complicated return objects are lists, ie from lm()

### for loops
Parts of a for loop

- sequence
- body
- 

```{r}
# looping over cols in a df
df <- data.frame(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

for (i in 1:ncol(df)) {
  print(median(df[[i]]))
}

```

Moving forward, we'll see a safer way to generate the sequence using `seq_along()` and saving the output instead of printing it. 

```{r}
# Replace the 1:ncol(df) sequence
for (i in seq_along(df)) {
  print(median(df[[i]]))
}

# Create an empty data frame
empty_df <- data.frame()

# Repeat for loop to verify there is no error
for (i in seq_along(empty_df)) {
  print(median(empty_df[[i]]))
}

# Create new double vector: output
output <- vector(mode = "double", ncol(df))

# Alter the loop
for (i in seq_along(df)) {
  # Change code to store result in output
  output[[i]] <- median(df[[i]])
}

# Print output
print(output)
```

# When and how you should write a function

### When?

- Copy-paste rule of thumb: Whenever you have copied-and-pasted twice, it's time to write a function

```{r}
# Define example vector x
x <- c(1:10, NA)

# Define rng
rng <- range(x, na.rm=TRUE)

# Rewrite this snippet to refer to the elements of rng
(x - min(x, na.rm = TRUE)) /
  (rng[2] - rng[1])

# Use this in function
rescale01 <- function(x) {
  rng <- range(x, na.rm=TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

# Test your function, call rescale01 using the vector x as the argument
rescale01(x)
```

### How?

1. Start with a simple problem. It is helpful if you know the answer.
2. Get a working snipped of code.
3. Rewrite to use temporary variables. Rewrite for clarity. Snippet is the body of the function. Temporary arguments are then the inputs
4. Turn into a function

```{r}
# Define example vectors x and y
x <- c( 1, 2, NA, 3, NA)
y <- c(NA, 3, NA, 3,  4)

# Count how many elements are missing in both x and y
sum(is.na(x) & is.na(y))

# Turn this snippet into a function: both_na()
both_na <- function(x,y){
  sum(is.na(x) & is.na(y))
}
```

Note that this function only works in cases where x and y have the same length. 

### How to write a good function?
Function is

- correct
- understandable
- readable for humans and computers
- correct + understandable = obviously correct

Naming the function as a verb which describes what it does is a good start. In addition, we should not use function names that are already taken nor use variables which have already a meaning (e.g. `T` or `c`).

```{r}
# Altered mean_ci function
mean_ci <- function(x, level = 0.95) {
  if (length(x) == 0) {
    warning("`x` was empty", 
    interval <- c(-Inf, Inf))
    return(interval)
  } else {
    se <- sd(x) / sqrt(length(x))
    alpha <- 1 - level
    mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
  }
}

mean_ci(numeric(0))
mean_ci(x)

# replace_missings function
replace_missings <- function(x, replacement) {
  x[is.na(x)] <- replacement
  cat(sum(is.na(x)), replacement, "\n")
  x
}

replace_missings(x, 0)

# A few more tweaks...
replace_missings <- function(x, replacement) {
  is_miss <- is.na(x)
  x[is_miss] <- replacement
  
  # Rewrite to use message()
  message(sum(is_miss), " missings replaced by the value ", replacement)
  x
}

replace_missings(x, replacement=10)

```

# Functional Programming


